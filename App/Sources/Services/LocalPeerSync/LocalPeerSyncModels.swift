//
//  Copyright Â© 2026 - Jan-Hendrik Damerau. All rights reserved.
//

import Foundation

/// Namespaces shared data models for local peer synchronization.
enum LocalPeerSyncModels {}

/// Defines global configuration values for local peer synchronization.
enum LocalPeerSyncConfiguration {
    /// The Bonjour service type used for peer discovery.
    static let bonjourServiceType = "_appsync._tcp"

    /// The supported protocol version.
    static let protocolVersion = 1

    /// The timeout in seconds used for pairing sessions.
    static let pairingLifetimeInSeconds: TimeInterval = 5 * 60
}

/// Defines notification names and payload keys for local peer sync events.
enum LocalPeerSyncNotifications {
    /// Emitted when a peer was successfully connected and trusted.
    static let peerConnected = NSNotification.Name("LocalPeerSync.PeerConnected")

    /// Emitted when sync activity starts or finishes for a peer.
    static let syncActivityChanged = NSNotification.Name("LocalPeerSync.SyncActivityChanged")

    /// Emitted when a peer requests incoming sync approval from the user.
    static let incomingSyncApprovalRequested = NSNotification.Name("LocalPeerSync.IncomingSyncApprovalRequested")

    /// The userInfo key storing the connected peer identifier.
    static let peerIdKey = "peerId"

    /// The userInfo key storing the connected peer display name.
    static let deviceNameKey = "deviceName"

    /// The userInfo key storing whether sync is currently active.
    static let isSyncingKey = "isSyncing"

    /// The userInfo key storing whether sync was initiated by an incoming sync request.
    static let isIncomingSyncRequestKey = "isIncomingSyncRequest"
}

/// Represents the supported message types in the peer sync protocol.
enum LocalPeerSyncMessageType: String, Codable, Sendable {
    /// Starts the pairing handshake from scanning peer to provider.
    case pairHello

    /// Confirms pairing challenge from provider back to scanner.
    case pairConfirm

    /// Finishes pairing handshake and confirms trust persistence.
    case pairDone

    /// Requests delta changes since a history token.
    case syncRequest

    /// Returns a delta package plus the new history token.
    case syncResponse

    /// Acknowledges the applied delta checkpoint.
    case ack

    /// Signals a protocol or processing failure.
    case error
}

/// Encodes a QR payload used to bootstrap peer pairing.
struct PairingQRCodePayload: Codable, Sendable {
    /// The pairing session identifier generated by the provider.
    let pairingSessionId: UUID

    /// The Bonjour service type that should be discovered.
    let bonjourServiceType: String

    /// The optional expected device identifier.
    let expectedPeerDeviceId: String?

    /// A short-lived secret used once during initial trust establishment.
    let pairingSecret: String

    /// The negotiated protocol version.
    let protocolVersion: Int

    /// The payload expiration date.
    let expiresAt: Date

    /// Returns whether the payload is still valid for the provided date.
    ///
    /// - Parameter now: The current reference date.
    /// - Returns: `true` when not expired.
    func isValid(at now: Date = Date()) -> Bool {
        now < expiresAt
    }
}

/// Describes a trusted peer persisted after successful pairing.
struct LocalPeerTrustRecord: Codable, Sendable, Equatable {
    /// The stable peer identifier.
    let peerId: String

    /// The human-readable device name.
    let deviceName: String

    /// The pinned key fingerprint for trust validation.
    let publicKeyFingerprint: String

    /// The time when the peer was paired.
    let pairedAt: Date

    /// The timestamp of the most recent successful sync.
    let lastSuccessfulSyncAt: Date?
}

/// Stores a serialized persistent history token for one sync direction.
struct LocalPeerHistoryCheckpoint: Codable, Sendable, Equatable {
    /// The paired peer identifier.
    let peerId: String

    /// The direction identifier, e.g. `outgoing` or `incoming`.
    let direction: String

    /// The archived persistent history token bytes.
    let tokenData: Data

    /// The save timestamp used for observability.
    let updatedAt: Date
}

/// Stores aggregated local sync statistics for one peer.
struct LocalPeerSyncStats: Codable, Sendable, Equatable {
    /// The trusted peer identifier.
    let peerId: String

    /// The cumulative synchronized payload size in bytes.
    let totalSyncedBytes: Int64

    /// The timestamp of the most recent transfer.
    let lastTransferAt: Date?
}

/// Represents a typed attribute value transferred in delta payloads.
enum LocalPeerSyncValue: Codable, Sendable, Equatable {
    /// Stores a string value.
    case string(String)

    /// Stores a 16-bit signed integer value.
    case int16(Int16)

    /// Stores a 32-bit signed integer value.
    case int32(Int32)

    /// Stores a 64-bit signed integer value.
    case int64(Int64)

    /// Stores a double value.
    case double(Double)

    /// Stores a boolean value.
    case bool(Bool)

    /// Stores a date value.
    case date(Date)

    /// Represents an explicit null value.
    case null

    /// Coding keys used for tagged enum encoding.
    private enum CodingKeys: String, CodingKey {
        case type
        case stringValue
        case int16Value
        case int32Value
        case int64Value
        case doubleValue
        case boolValue
        case dateValue
    }

    /// Supported type tags for coded values.
    private enum ValueType: String, Codable {
        case string
        case int16
        case int32
        case int64
        case double
        case bool
        case date
        case null
    }

    /// Creates a new value from a decoder.
    ///
    /// - Parameter decoder: The decoder containing the value payload.
    /// - Throws: Any decoding error encountered.
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(ValueType.self, forKey: .type)

        switch type {
        case .string:
            self = try .string(container.decode(String.self, forKey: .stringValue))
        case .int16:
            self = try .int16(container.decode(Int16.self, forKey: .int16Value))
        case .int32:
            self = try .int32(container.decode(Int32.self, forKey: .int32Value))
        case .int64:
            self = try .int64(container.decode(Int64.self, forKey: .int64Value))
        case .double:
            self = try .double(container.decode(Double.self, forKey: .doubleValue))
        case .bool:
            self = try .bool(container.decode(Bool.self, forKey: .boolValue))
        case .date:
            self = try .date(container.decode(Date.self, forKey: .dateValue))
        case .null:
            self = .null
        }
    }

    /// Encodes the value into an encoder.
    ///
    /// - Parameter encoder: The encoder receiving the payload.
    /// - Throws: Any encoding error encountered.
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        switch self {
        case let .string(value):
            try container.encode(ValueType.string, forKey: .type)
            try container.encode(value, forKey: .stringValue)
        case let .int16(value):
            try container.encode(ValueType.int16, forKey: .type)
            try container.encode(value, forKey: .int16Value)
        case let .int32(value):
            try container.encode(ValueType.int32, forKey: .type)
            try container.encode(value, forKey: .int32Value)
        case let .int64(value):
            try container.encode(ValueType.int64, forKey: .type)
            try container.encode(value, forKey: .int64Value)
        case let .double(value):
            try container.encode(ValueType.double, forKey: .type)
            try container.encode(value, forKey: .doubleValue)
        case let .bool(value):
            try container.encode(ValueType.bool, forKey: .type)
            try container.encode(value, forKey: .boolValue)
        case let .date(value):
            try container.encode(ValueType.date, forKey: .type)
            try container.encode(value, forKey: .dateValue)
        case .null:
            try container.encode(ValueType.null, forKey: .type)
        }
    }
}

/// Identifies one logical record in a Core Data entity.
struct LocalPeerEntityIdentity: Codable, Sendable, Equatable {
    /// The attribute name used as the identifier.
    let key: String

    /// The attribute value used as the identifier.
    let value: LocalPeerSyncValue
}

/// Represents one upsert operation in a delta payload.
struct LocalPeerSyncUpsert: Codable, Sendable, Equatable {
    /// The Core Data entity name.
    let entityName: String

    /// The identity selector for deterministic matching.
    let identity: LocalPeerEntityIdentity

    /// The full field snapshot to apply.
    let fields: [String: LocalPeerSyncValue]

    /// The modification timestamp for conflict resolution.
    let modifiedAt: Date

    /// The schema version of this upsert payload.
    let version: Int
}

/// Represents one delete operation in a delta payload.
struct LocalPeerSyncDelete: Codable, Sendable, Equatable {
    /// The Core Data entity name.
    let entityName: String

    /// The identity selector of the deleted record.
    let identity: LocalPeerEntityIdentity

    /// The deletion timestamp for conflict resolution.
    let deletedAt: Date
}

/// Represents a delta payload for one sync cycle.
struct LocalPeerSyncDelta: Codable, Sendable, Equatable {
    /// The upsert operations that should be applied.
    let upserts: [LocalPeerSyncUpsert]

    /// The delete operations that should be applied.
    let deletes: [LocalPeerSyncDelete]

    /// The archived new history token after delta creation.
    let newTokenData: Data
}

/// Defines the envelope exchanged over transport.
struct LocalPeerSyncMessage: Codable, Sendable {
    /// The unique message identifier.
    let id: UUID

    /// The protocol version used by this message.
    let protocolVersion: Int

    /// The sender timestamp in UTC.
    let sentAt: Date

    /// The specific message type.
    let type: LocalPeerSyncMessageType

    /// The optional pairing session identifier.
    let pairingSessionId: UUID?

    /// The optional pairing secret.
    let pairingSecret: String?

    /// The optional peer identifier.
    let peerId: String?

    /// The optional device name for pairing and diagnostics.
    let deviceName: String?

    /// The optional public key fingerprint used for trust pinning.
    let publicKeyFingerprint: String?

    /// The optional token data used in sync requests.
    let sinceTokenData: Data?

    /// The optional delta payload used in sync responses.
    let delta: LocalPeerSyncDelta?

    /// The optional acknowledged token data.
    let ackTokenData: Data?

    /// The optional machine-readable error code.
    let errorCode: String?

    /// The optional human-readable error reason.
    let errorMessage: String?
}
